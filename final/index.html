<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
    />
    <title>Record Linkage of Fatal Force Data</title>
    <meta property="og:title" content="Record Linkage of Fatal Force Data" />
    <meta charset="utf-8" />
    <meta property="og:type" content="article" />

    <meta property="og:description" content="This project seeks to complile and link heterogenous crowdsourced data on fatal police deaths." />
    <meta property="description" content="This project seeks to complile and link heterogenous crowdsourced data on fatal police deaths." />
    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css"
    />

    <link rel="stylesheet" href="static/idyll_styles.css" />
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><div class=" idyll-text-container"></div><div class="article-header" style="background:#dddddd;color:#ff4545"><h1 class="hed">Record Linkage of Fatal Force Data</h1><h2 class="dek">Combining crowd sourced data to better understand deaths from police</h2><div class="byline">By: <a>Vaughn Johnson</a></div><div class="idyll-pub-date">Wed Jun 12 2019</div></div><div class=" idyll-text-container"><h1>Context</h1><p>Every year hundreds of people are shot and killed by the people entrusted to protect them. 
As of 2019-06-09, <strong>3<!-- -->9<!-- -->4 <!-- -->people</strong> have been killed by the police in the United States.
There is no official reporting done by the government to keep track of police violence, and
by extension there is no central repository for data surrounding these deaths. That data 
is crucial both in better understanding police violence and in holding the police accountable
for using fatal force.</p><p>However, as is so often the case, communities have come together in the face of 
oppression to crowdsource data on these deaths. There are several compiled sources, but my
reserach has focused primarily on 4 datasets</p><ul><li><a href="killedbypolice.net">Killed By Police</a></li><li><a href="https://www.washingtonpost.com/graphics/2019/national/police-shootings-2019/">The Washington Post’s Police Shooting Database</a></li><li><a href="https://mappingpoliceviolence.org/">Mapping Police Violence</a></li><li><a href="https://fatalencounters.org/">Fatal Encounters</a></li></ul><p>
Fatal Encounters has data dating back to 2000, 
while the other repositories only have data going back to 2013 (and in the case of WaPo, only 2015). 
Killed By Police and Fatal Encounters are orignal datasets, whereas WaPo and Mapping Police Violence are 
both derivative datasets that contribute additional information. In total, the combined data sources 
have around <strong>3<!-- -->5<!-- -->K</strong> records.</p><p>Each of these datasets contains slightly different pieces of information. Some of the data is missing in
some datasets while present in others. What we would like to do is combine these datasets together 
such that we can infer any missing values (such as race), and enrich the total amount of information we 
have on each victim.</p><p>Unfortunately, stitching these datasets together is non-trivial; the datasets have inconsistent naming 
and formatting conventions, there are typos and missing data, and people will sometimes appear in 
some but not all of the datasets. What we need is a more general approach to merging records that
can handle more inconsistent data.</p><h1>Record Linkage</h1><p>There is in fact already such a method: <strong>Record Linkage</strong>.</p><p>A record is a row in a table which points to a particular entity such as a medical patient, or a victim of police violence. 
Record Linkage was developed in the 1960′s as a solution to the problem of matching patients to 
their medical and insurance records. In 1969, Ivan Fellegi and Alan Sunter published an 
approach to Record Linkage that has proven to be so effective it is still the modern prototype
for how Record Linkage is done today. Their general idea goes like this:</p><ol><li>Enumerate all the possible pairs of records across the datasets you want to combine</li><li>Quantify some measure of distance between each pair</li><li>Use some mathematical magic to assign a weight to each pair to corresponds to the probability they are matched</li><li>Based on that weight, classify each pair as <em>matching</em>, <em>non-matching</em>, and <em>indeterminant</em>.</li></ol><p>
Each step lots of details and caveats that I’ll go into details below. </p><h2>1<!-- -->) Enumerate pairs</h2><p>The first step is to find all the possible pairs of records. The Fellegi &amp; Sunter method 
is very general, and doesn’t care if you are pulling records from two different datasets  
or the same dataset, so long as the datasets have some rows in common. Therefore, not only 
can we find if a person is present in more than one dataset, but also if that person
appears in the same dataset twice! 


The solution is to limit which pairs we actually consider. For example, it is almost never the 
case that two records which are true matches will have two disctinct values for year. Therefore,
when we enumerate all the possible pairs, we can immediately reject those pairs which do not already
match on year. This method is called blocking, and dramatically reduces the number of pairs we need
to consider. For the fatal force datasets, I blocked the data on year and US state, which reduced
the number of pairs by a factor of 600.</p><p>Below we have two sets of records we’re trying to match. You can select different radio buttons
to see how blocking reduces the number of pairs we have to consider.</p><div><label><input type="radio" value="none" name="0"/>none</label><label><input type="radio" value="year" name="0"/>year</label><label><input type="radio" value="state" name="0"/>state</label><label><input type="radio" value="sex" name="0"/>sex</label><label><input type="radio" value="race" name="0"/>race</label></div><div style="width:100%"></div><p>Now, as you can see, as the number of records we’re considering grows, the number of
possible pairs grows <em>really</em> fast. If you have any experience with algorithms, you’re likely already worried about the 
combinatoric nature of this step. Given that we have around 35K records, that means 
there are around 600M pairs that we have to consider. What’s worse is that the “mathematical magic”
we’ll use to assign each pair a weight involves iterating over every pair several times,
not to mention this dataset is growing nearly every day.</p><h2>2<!-- -->) Quantify Distance</h2><p>After Step 1 we now have a list of every possible pair. Each record in each pair will have
a set of values (e.g. <code>name</code>, <code>race</code>, etc.). Our goal is to quantify some idea of distance for 
each field in each pair. For example, say we have</p><button>
New Pair</button><div style="width:100%"></div><p>Each column refers to a different type of data, and we need to be conscious of how we compare
different data types. In the case of an integer like <code>year</code>, we can just take the actual difference 
of the two values</p><div style="width:100%"></div><p>For data types like strings, there are other methods for comparing distance such as <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein</a>
and <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro–Winkler</a></p><p>For factors like sex where there isn’t a sensible idea of being <em>distant</em> other than being simply <em>different</em>, we assign <code>true</code> for identical and <code>false</code> for non-identical values</p><div style="width:100%"></div><p>We can perform this process for each column of each pair. The end result would look something like this</p><div style="width:100%"></div><p>We can think of a particular pair’s set of comparison values as a vector</p><p>Fellegi &amp; Sunter refer to this vector as <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span>, and that’s also how I’ll refer to it for the remainder of a document.</p><h2>3<!-- -->) Assign Weights</h2><p>Once we have a <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> for each pair of records, we want to assign weight to each pair based on how likely we think that
that particular pair is a match. The way Fellegi and Sunter go about doing this is by making use of two functions</p><span style="display:block"><span> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>γ</mi><mo>)</mo><mo>=</mo><mi>P</mi><mo>(</mo><mi>γ</mi><mi mathvariant="normal">∣</mi><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">m(\gamma) = P(\gamma | \mathrm{match})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">m</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mord">∣</span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">c</span><span class="mord mathrm">h</span></span><span class="mclose">)</span></span></span></span></span> </span></span><span style="display:block"><span> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>(</mo><mi>γ</mi><mo>)</mo><mo>=</mo><mi>P</mi><mo>(</mo><mi>γ</mi><mi mathvariant="normal">∣</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">u(\gamma) = P(\gamma | \mathrm{nonmatch})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">u</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mord">∣</span><span class="mord"><span class="mord mathrm">n</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">c</span><span class="mord mathrm">h</span></span><span class="mclose">)</span></span></span></span></span> </span></span><p>If you’re unfamiliar with the notation,
it reads “m of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> 
is the probability of observing <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> 
given the pair is a match”,
and of course “u of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> 
is the probability of observing <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> 
given the pair is a nonmatch”. For the time being, don’t worry how we get these values (I’ll get to it).</p><p>For each pair we can plug in <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> 
and get an <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
and a <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span>.
Fellegi &amp; Sunter generate a single weight <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span></span> </span></span> 
by dividing <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
by <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span>, 
and for mathematical convience, we can also take the log.<span style="display:block"><span> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>γ</mi><mo>)</mo><mo>=</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mfrac><mrow><mi>m</mi><mo>(</mo><mi>γ</mi><mo>)</mo></mrow><mrow><mi>u</mi><mo>(</mo><mi>γ</mi><mo>)</mo></mrow></mfrac><mo>)</mo><mo>=</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>m</mi><mo>(</mo><mi>γ</mi><mo>)</mo><mo>)</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>u</mi><mo>(</mo><mi>γ</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">w(\gamma) = \log(\frac{m(\gamma)}{u(\gamma)}) = \log(m(\gamma)) - \log(u(\gamma))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.427em;"></span><span class="strut bottom" style="height:2.363em;vertical-align:-0.936em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">u</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width='400em' height='0.2em' viewBox='0 0 400000 200' preserveAspectRatio='xMinYMin slice'><path d='M0 80H400000 v40H0z M0 80H400000 v40H0z'/></svg></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">m</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span> </span></span>
This assigns high weights to pairs have the two properties that</p><ol><li>Likely to occur given they are a match</li><li>Unlikely to occur if not a match</li></ol><p>The way we actually estimate <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> 
is somewhat complicated, bordering on the side of magic. In order to figure out <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> 
we would simply count how often we find each <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span> 
in a pair that is actually matched and divide by the total number of times we observe <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05556em;">γ</span></span></span></span> </span></span>,
and that tells us <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span>, 
(similarly for <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span>
). However, obviously we don’t know which records are true matches before we perform Record Linkage! 
We have a seemingly intractable chicken and egg problem.</p><p>The solution is quite clever. The way statisticians usually start with problems like this is by finding 
a liklihood, or the probability of observing the particular set of observations we have. Once we have a likelihood function, we  
can take its derivate with respect to <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span>
and to <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> 
and find the forms of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> 
that maximize the likelihood. Unfortunately, the liklihood is also a function of whether each pair is a match,
which is something we don’t know a priori. The solution is to guess the latent variable, and find the 
liklihood of that guess.
We can then take the derivative, find the maximizing values of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span>, 
and find some estimates of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span>.</p><p>We can then take those new estimates and make new guesses about the latent matching variable. By iteratating this 
process, our values of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> 
converge.</p><h2>4</h2><p>Once we have a weight for each pair, we can line up each pair in order of its weight. 
This creates a distribution:</p><p>We can then segment the pairs into three categories based on their weight: <code>match</code>, <code>nonmatch</code>, and <code>indeterminant</code>.
The way we draw the line between <code>match</code>, <code>nonmatch</code>, and <code>indeterminant</code> is based on the sum of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
and <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> 
in each bucket.</p><p>By resticting the sum of <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">u</span></span></span></span> </span></span> in the <code>match</code>
category and the sum <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> </span></span> 
in the <code>nonmatch</code> bucket, we effectively limit the number of 
false positives and false negatives we make.</p><h1>Results</h1><p>I was able to effectively link and merge the four datasets. The results are below</p><div class="aside-container"><div class="aside"><input type="range" value="2015" min="2010" max="2016" step="1"/><span class="idyll-display">2015.00</span><div><label><input type="radio" checked="" value="All" name="1"/>All</label><label><input type="radio" value="Male" name="1"/>Male</label><label><input type="radio" value="Female" name="1"/>Female</label><label><input type="radio" value="Other / NA" name="1"/>Other / NA</label></div><span class="idyll-display">All</span><div><label><input type="radio" checked="" value="All" name="2"/>All</label><label><input type="radio" value="White" name="2"/>White</label><label><input type="radio" value="Black" name="2"/>Black</label><label><input type="radio" value="Asian" name="2"/>Asian</label><label><input type="radio" value="Other / NA" name="2"/>Other / NA</label></div><span class="idyll-display">All</span></div></div><p><strong>Year</strong>
<span class="idyll-display">2015.00</span><div style="width:100%"></div></p><p><strong>Race</strong>
<span class="idyll-display">All</span></p><div style="width:100%"></div><p><strong>Sex</strong>
<span class="idyll-display">All</span></p><div style="width:100%"></div><h2>Fatal Police Encounters Per <!-- -->1<!-- -->0<!-- -->0<!-- -->,<!-- -->0<!-- -->0<!-- -->0 <!-- -->People</h2><div style="width:100%"></div><div class="aside-container"><div class="aside">
  (Duplicated for you convenience)
  <input type="range" value="2015" min="2010" max="2016" step="1"/><span class="idyll-display">2015.00</span><div><label><input type="radio" checked="" value="All" name="3"/>All</label><label><input type="radio" value="Male" name="3"/>Male</label><label><input type="radio" value="Female" name="3"/>Female</label><label><input type="radio" value="Other / NA" name="3"/>Other / NA</label></div><span class="idyll-display">All</span><div><label><input type="radio" checked="" value="All" name="4"/>All</label><label><input type="radio" value="White" name="4"/>White</label><label><input type="radio" value="Black" name="4"/>Black</label><label><input type="radio" value="Asian" name="4"/>Asian</label><label><input type="radio" value="Other / NA" name="4"/>Other / NA</label></div><span class="idyll-display">All</span></div></div></div></div></div></div>
    <script src="static/idyll_index.js"></script>
  </body>
</html>
